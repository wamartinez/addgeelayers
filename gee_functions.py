# -*- coding: utf-8 -*-
"""
/***************************************************************************
 addgeelayersDialog
                                 A QGIS plugin
 Add NDVI, PCA, false color layers to QGIS using GEE
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-07-06
        git sha              : $Format:%H$
        copyright            : (C) 2021 by William Martinez
        email                : willimarti2008@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from ee_plugin import Map
import ee
import ogr
import pandas as pd
from qgis.PyQt.QtWidgets import QMessageBox

#======================================================
#functions
#======================================================


#This function performs a simple cloud masking using metadata
def maskL8sr(image):
    #Bits 3 and 5 are cloud shadow and cloud, respectively.
    cloudShadowBitMask = 8
    cloudsBitMask = 32
    #Get the pixel QA band.
    qa = image.select('pixel_qa')
    #Both flags should be set to zero, indicating clear conditions.
    mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0) and qa.bitwiseAnd(cloudsBitMask).eq(0)
    return image.updateMask(mask)
   

def cloudMaskL457(image):
  qa = image.select('pixel_qa')
  #If the cloud bit (5) is set and the cloud confidence (7) is high
  #or the cloud shadow bit is set (3), then it's a bad pixel.
  cloud = (qa.bitwiseAnd(32).eq(0) and(qa.bitwiseAnd(128)).eq(0)) or(qa.bitwiseAnd(8)).eq(0)
  #Remove edge pixels that don't occur in all bands
  mask2 = image.mask().reduce(ee.Reducer.min())
  return image.updateMask(cloud).updateMask(mask2)

def normalization_img(img, bands_s,polygon):
    subset = img.select(bands_s)
    percentiles = subset.reduceRegion(reducer = ee.Reducer.percentile([1, 99], ['min', 'max']),
                geometry = polygon,
                scale = 30,
                maxPixels = 1e9).getInfo()

    minVal = [val for key, val in percentiles.items() if 'min' in key]
    maxVal = [val for key, val in percentiles.items() if 'max' in key]

    specif_color = {
    'bands': bands_s,
    'min': list(reversed(minVal)), 
    'max': list(reversed(maxVal)),
    }
    return specif_color
    
def normalization_pca(componentsImage,polygon):
    componentsImage_1 = componentsImage.select(['brightness','greenness','wetness'])
    percentiles = componentsImage_1.reduceRegion(reducer = ee.Reducer.percentile([1, 99], ['min', 'max']),
                geometry = polygon,
                scale = 30,
                maxPixels = 1e9).getInfo()

    minVal = [val for key, val in percentiles.items() if 'min' in key]
    maxVal = [val for key, val in percentiles.items() if 'max' in key]

    specif_color = {
    'bands': ['brightness','greenness','wetness'],
    'min': list(minVal), 
    'max': list(maxVal),
    }
    return specif_color    
    

#NDVI
def addndvi_57(image):
  return image.addBands(image.normalizedDifference(['B4', 'B3']))\
        .addBands(image.metadata('system:time_start'))

def addndvi_8(image):
  return image.addBands(image.normalizedDifference(['B5', 'B4']))\
        .addBands(image.metadata('system:time_start'))


#======================================================
#PCA matrix
#======================================================

#Define an Array of Tasseled Cap coefficients.
coefficients_L8 = ee.Array([
    [0.3029, 0.2786, 0.4733, 0.5599, 0.508, 0.1872],
    [-0.2941, -0.2435, -0.5424, 0.7276, 0.0713, -0.1608],
    [0.1511, 0.1973, 0.3283, 0.3407, -0.7117, -0.4559],
    [-0.8239, 0.0849, 0.4396, -0.0580, 0.2013, -0.2773],
    [-0.3294, 0.0557, 0.1056, 0.1855, -0.4349, 0.8085],
    [0.1079, -0.9024, 0.4119, 0.0575, -0.0259, 0.0252]
    ])
    
coefficients_L7 = ee.Array([
    [0.3561, 0.3972, 0.3904, 0.6966, 0.2286, 0.1596],
    [-0.3344, -0.3544, -0.4556, 0.6966, -0.0242, -0.2630],
    [0.2626, 0.2141, 0.0926, 0.0656, -0.7629, -0.5388],
    [0.0805, -0.0498, 0.1950, -0.1327, 0.5752, -0.7775],
    [-0.7252, -0.0202, 0.6683, 0.0631, -0.1494, -0.0274],
    [0.4000, -0.8172, 0.3832, 0.0602, -0.1095, 0.0985]
    ])
    
coefficients_L5 = ee.Array([
  [0.3037, 0.2793, 0.4743, 0.5585, 0.5082, 0.1863],
  [-0.2848, -0.2435, -0.5436, 0.7243, 0.0840, -0.1800],
  [0.1509, 0.1973, 0.3279, 0.3406, -0.7112, -0.4572],
  [-0.8242, 0.0849, 0.4392, -0.0580, 0.2012, -0.2768],
  [-0.3280, 0.0549, 0.1075, 0.1855, -0.4357, 0.8085],
  [0.1084, -0.9022, 0.4120, 0.0573, -0.0251, 0.0238]
])



def map_gee_layers(self,list_extent,start_date,end_date,computation,state_ndvi,state_pca,state_fc,state_tc):
       #Create an ee.Geometry.
       polygon = ee.Geometry.Polygon([list_extent])
       #imagery
       year_pd = pd.Series(int(start_date.toString("yyyy")))
       y_L5 = list(range(1980,2000))
       y_L7 = list(range(2000,2014))
       y_L8 = list(range(2014,2021))
       if any(year_pd.isin(y_L5)):
              id_imagery = 'LANDSAT/LT05/C01/T1_SR'
       elif any(year_pd.isin(y_L7)):
              id_imagery = 'LANDSAT/LE07/C01/T1_SR'
       elif any(year_pd.isin(y_L8)):
              id_imagery = 'LANDSAT/LC08/C01/T1_SR'

       #This function clips the image according with a polygon
       def clipToCol(image):
              return image.clip(polygon)

       dataset = ee.ImageCollection(id_imagery)\
              .filterDate(str(start_date.toString("yyyy-MM-dd")),str(end_date.toString("yyyy-MM-dd")))\
              .filterBounds(polygon)\
              .map(clipToCol)

       if dataset.size().getInfo() == 0:
              QMessageBox.information(self.dlg,"Message","No images are available for this period.")
       else:
              #processing       
              if any(year_pd.isin(y_L5)):
                     bands_s_fc = ['B4', 'B3', 'B2']
                     bands_s_tc = ['B3', 'B2', 'B1']
                     dataset_sa_masked = dataset.map(cloudMaskL457).map(addndvi_57)
              elif any(year_pd.isin(y_L7)):
                     bands_s = ['B4', 'B3', 'B2']
                     bands_s_tc = ['B3', 'B2', 'B1']
                     dataset_sa_masked = dataset.map(cloudMaskL457).map(addndvi_57)
              elif any(year_pd.isin(y_L8)):
                     bands_s = ['B5', 'B4', 'B3']
                     bands_s_tc = ['B4', 'B3', 'B2']
                     dataset_sa_masked = dataset.map(maskL8sr).map(addndvi_8)
              #taking the most photosintetic active pixel

              if computation == "Median":
                     composite = ee.Image(dataset_sa_masked.median())
              elif computation == "Max NDVI":
                     composite = dataset_sa_masked.qualityMosaic('nd')
              elif computation == "Most recent":
                     composite = dataset_sa_masked.qualityMosaic('system:time_start')

              #======================================================
              #False color
              #======================================================
              if state_fc == 2:
                     specif_color = normalization_img(composite, bands_s,polygon)
                     Map.addLayer(composite,specif_color, 'FalseColor')

              #======================================================
              #True color
              #======================================================
              if state_tc == 2:
                     specif_color = normalization_img(composite, bands_s_tc,polygon)
                     Map.addLayer(composite,specif_color, 'TrueColor')
              #======================================================
              #NDVI
              #======================================================
              if state_ndvi == 2:
                     color_specif = {
                     'min':-1, 
                     'max':1, 
                     'palette': ["red", "orange", "yellow", "green"]}
                     Map.addLayer(composite.select('nd'),color_specif, 'NDVI')

              #======================================================
              #PCA
              #======================================================
              if state_pca == 2:
                     if any(year_pd.isin(y_L5)):
                            bands = ['B1','B2','B3', 'B4', 'B5','B7']
                            subset_dry = composite.select(bands)
                            coefficients = coefficients_L5
                     elif any(year_pd.isin(y_L7)):
                            bands = ['B1','B2','B3', 'B4', 'B5','B7']
                            subset_dry = composite.select(bands )
                            coefficients = coefficients_L7
                     elif any(year_pd.isin(y_L8)):
                            bands = ['B2','B3','B4', 'B5', 'B6','B7']
                            subset_dry = composite.select(bands )
                            coefficients = coefficients_L8

                     #Make an Array Image, with a 1-D Array per pixel.
                     arrayImage1D = subset_dry.toArray()

                     #Make an Array Image with a 2-D Array per pixel, 6x1.
                     arrayImage2D = arrayImage1D.toArray(1)

                     #Do a matrix multiplication: 6x6 times 6x1.
                     componentsImage = ee.Image(coefficients)\
                     .matrixMultiply(arrayImage2D)\
                     .arrayProject([0])\
                     .arrayFlatten([['brightness', 'greenness', 'wetness', 'fourth', 'fifth', 'sixth']])

                     specif_color_pca = normalization_pca(componentsImage,polygon)
                     Map.addLayer(componentsImage,specif_color_pca, 'PCA')